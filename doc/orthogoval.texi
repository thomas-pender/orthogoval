\input texinfo @c -*-texinfo-*-

@setfilename orthogoval.info

@settitle Mutually Orthogoval Affine Planes 0.0

@copying
Copyright @copyright{} 2025 Thomas Pender.

@quotation
Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.3 or
any later version published by the Free Software Foundation; with no
Invariant Sections, no Front-Cover Texts, and no Back-Cover Texts. A
copy of the license is included in the section entitled ``GNU Free
Documentation License.''
@end quotation
@end copying

@contents

@node Top
@top

The package contains exectuables to search for maximal sets of mutually orthogoval
translation affine planes of even order.

@menu

* Sec 1:: Synopsis
* Sec 2:: Compilation and Installation
* Sec 3:: Class Documentation
* Sec 4:: Executable Documentation
* Sec 5:: GNU Free Documentation License

@end menu

@insertcopying

@node Sec 1
@chapter Synopsis

hello world

@node Sec 2
@chapter Compilation and Installation

@enumerate
@item Download and unpack the tarball.
@item From the root directory of the project, create the build directory and move
there with @code{mkdir build && cd build}.
@item Configure with @code{../configure}. The optimizations can be adjusted by
running instead @code{../configure CFLAGS="-O3"}.
@item Compile with @code{make}. The executables are contained in the @code{src}
subdirectory of the @code{build} directory created in step 2.
@end enumerate

@node Sec 3
@chapter Class Documentation

There are two classes in this project:

@menu

* matrix.h:: A boolean matrix class.
* ag.h:: A boolean spread class.

@end menu

@node matrix.h
@section matrix.h

@menu
Class Types:
@itemize
@item @code{typedef typename std::pair<std::size_t, std::size_t> dimensions}
@item @code{typedef typename std::vector<std::uint32_t> container}
@item @code{typedef typename container::iterator iterator}
@item @code{typedef typename container::const_iterator const_iterator}
@end itemize

Friend Functions:
* matrix operator<<:: output container
* matrix operator>>:: input container
* matrix operator*:: multiplicative arithmetic

Element Access:
* matrix operator[]:: row access
* matrix data:: return container
* matrix at:: entry access

Member Functions:
* matrix transpose:: return transpose of @code{*this}
* matrix operator==:: check equality between matrices
* matrix operator<=>:: total ordering on matrix class
* matrix operator*=:: assigmment matrix-matrix multiplication
* matrix print:: print matrix in standard/array form
* matrix inverse:: return inverse of @code{*this}
* matrix gauss_form:: return row echelon form
* matrix rref:: return reduced row echelon form
* matrix rank:: return rank of matrix
* matrix row_space:: print nonzero vectors in row space (assumes full rank)
* matrix shape:: return row-column dimensions
* matrix nrows:: return number of rows
* matrix ncols:: return number of columns
* matrix resize:: resize matrix to new dimensions
* matrix assignment:: assigning matrices
* matrix constructors/destructor:: constructing and destructing matrices
@end menu

@lowersections

@node matrix operator<<
@unnumberedsec operator<<

@deftypefn {friend} std::ostream& operator<<(std{::}ostream&, matrix const&)
output integer value of each row of matrix
@end deftypefn

@noindent Example:

@noindent ------------------------------code block------------------------------

@noindent # include <iostream>@*
# include <vector>@*
# include <matrix.h>

@noindent int main(void)@*
@{@*
@ @ matrix A@{std::vector<std::uint32_t>@{1, 2@}, 5@};

@noindent@ @ std::cout << A << '\n';

@noindent@ @ return 0;@*
@}

@noindent ----------------------------end code block----------------------------

@noindent Output:@*
@ @ 1 2

@node matrix operator>>
@unnumberedsec operator>>

@deftypefn {friend} std::istream& operator>>(std::istream&, matrix&)
input container
@end deftypefn

@noindent Example:

@noindent ------------------------------code block------------------------------

@noindent # include <iostream>@*
# include <matrix.h>

@noindent int main(void)@*
@{@*
@ @ matrix A@{2, 5@};

@noindent@ @ std::cin >> A;@*
@noindent@ @ A.print(std::cout);

@noindent@ @ return 0;@*
@}

@noindent ----------------------------end code block----------------------------

@noindent Input:@*
@ @ 1 2

@noindent Output:@*
@ @ 0 0 0 0 1@*
@ @ 0 0 0 1 0

@node matrix operator*
@unnumberedsec operator*

@deftypefn {friend} matrix operator*(matrix const&, matrix const&)
matrix-matrix multiplication
@end deftypefn

@deftypefn {friend} std::uint32_t operator*(matrix const&, std::uint32_t)
matrix-vector multiplication
@end deftypefn

@deftypefn {friend} std::uint32_t operator*(std::uint32_t, matrix const&)
vector-matrix multiplication
@end deftypefn

@noindent Example:

@noindent ------------------------------code block------------------------------

@noindent # include <iostream>@*
# include <vector>@*
# include <matrix.h>

@noindent int main(void)@*
@{@*
@ @ std::uint32_t v@{1@}, u@{@};@*
@ @ matrix A@{std::vector<std::uint32_t>@{2, 1@}, 5@};@*
@ @ matrix B@{std::vector<std::uint32_t>@{1, 2@}, 2@};

@noindent @ @ std::cout << "A =\n";@*
@ @ A.print(std::cout);@*
@ @ std::cout << "\n\n";

@noindent @ @ std::cout << "B =\n";@*
@ @ B.print(std::cout);@*
@ @ std::cout << "\n\n";

@noindent @ @ matrix C@{B * A@};@*
@ @ std::cout << "C =\n";@*
@ @ C.print(std::cout);@*
@ @ std::cout << "\n\n";

@noindent @ @ u = A * v;@*
@ @ std::cout << "u = " << u << '\n';

@noindent @ @ u = v * B;@*
@ @ std::cout << "u = " << u << '\n';

@noindent@ @ return 0;@*
@}

@noindent ----------------------------end code block----------------------------

@noindent Output:@*
@ @ A =@*
@ @ 0 0 0 1 0@*
@ @ 0 0 0 0 1

@noindent @ @ B =@*
@ @ 0 1@*
@ @ 1 0

@noindent @ @ C =@*
@ @ 0 0 0 0 1@*
@ @ 0 0 0 1 0

@noindent @ @ u = 1@*
@ @ u = 2

@node matrix operator[]
@unnumberedsec operator[]

@deftypefn {member} std::uint32_t& operator[](std::size_t) &
@deftypefnx {member} std::uint32_t operator[](std::size_t) &&
@deftypefnx {member} std::uint32_t const& operator[](std::size_t) const&
row access
@end deftypefn

@noindent Example:

@noindent ------------------------------code block------------------------------

@noindent # include <iostream>@*
# include <vector>@*
# include <matrix.h>

@noindent int main(void)@*
@{@*
@ @ matrix A@{std::vector<std::uint32_t>@{2, 1@}, 5@};@*
@ @ std::uint32_t row1@{A[0]@};

@noindent @ @ std::cout << "A = " << A << "row1 = " << row1 << '\n';

@noindent@ @ return 0;@*
@}

@noindent ----------------------------end code block----------------------------

@noindent Output:@*
@ @ A = 2 1@*
@ @ row1 = 2

@node matrix data
@unnumberedsec data

@deftypefn {member} container& data() &
@deftypefnx {member} container data() &&
@deftypefnx {member} container const& data() const&
return container
@end deftypefn

@noindent Example:

@noindent ------------------------------code block------------------------------

@noindent # include <iostream>@*
# include <vector>@*
# include <matrix.h>

@noindent int main(void)@*
@{@*
@ @ matrix A@{std::vector<std::uint32_t>@{1, 2, 3, 4@}@};@*
@ @ std::vector<std::vector<std::uint32_t> > vec@{A.data()@};

@noindent @ @ for ( auto it = vec.begin(); it != vec.end(); it++ )@*
@ @ @ @ std::cout << *it << " ";@*
@ @ std::cout << '\n';

@noindent@ @ return 0;@*
@}

@noindent ----------------------------end code block----------------------------

@noindent Output:@*
@ @ 1 2 3 4

@node matrix at
@unnumberedsec at

@deftypefn {member} std::uint32_t at(std::size_t, std::size_t) const
entry access
@end deftypefn

@noindent Example:

@noindent ------------------------------code block------------------------------

@noindent # include <iostream>@*
# include <vector>@*
# include <matrix.h>

@noindent int main(void)@*
@{@*
@ @ matrix A@{identity_matrix32(4)@};

@noindent @ @ std::cout << "A =\n";@*
@ @ A.print(std::cout);@*
@ @ std::cout << "\nentry (0, 0) = " << A.at(0, 0) << '\n';

@noindent@ @ return 0;@*
@}

@noindent ----------------------------end code block----------------------------

@noindent Output:@*
@ @ A =@*
@ @ 1 0 0 0@*
@ @ 0 1 0 0@*
@ @ 0 0 1 0@*
@ @ 0 0 0 1

@noindent @ @ entry (0, 0) = 1

@node matrix transpose
@unnumberedsec transpose

@deftypefn {member} matrix transpose() const
return transpose of @code{*this}
@end deftypefn

@noindent Example:

@noindent ------------------------------code block------------------------------

@noindent # include <iostream>@*
# include <vector>@*
# include <matrix.h>

@noindent int main(void)@*
@{@*
@ @ matrix A@{std::vector<std::uint32_t>@{2, 1@}, 5@};

@noindent @ @ std::cout << "A =\n";@*
@ @ A.print(std::cout);@*
@ @ std::cout << "\nA^T =\n";@*
@ @ A.transpose().print(std::cout);

@noindent@ @ return 0;@*
@}

@noindent ----------------------------end code block----------------------------

@noindent Output:@*
@ @ A =@*
@ @ 0 0 0 1 0@*
@ @ 0 0 0 0 1

@noindent @ @ A^T =@*
@ @ 0 0@*
@ @ 0 0@*
@ @ 0 0@*
@ @ 1 0@*
@ @ 0 1

@node matrix operator==
@unnumberedsec operator==

@deftypefn {member} bool operator==(matrix const&) const
check equality between matrices
@end deftypefn

@noindent Example:

@noindent ------------------------------code block------------------------------

@noindent # include <iostream>@*
# include <vector>@*
# include <matrix.h>

@noindent int main(void)@*
@{@*
@ @ matrix A@{std::vector<std::uint32_t>@{2, 1@}, 5@};@*
@ @ matrix B@{std::vector<std::uint32_t>@{1, 2@}, 5@};

@noindent @ @ std::cout << (A == A ? "true\n" : "false\n");@*
@ @ std::cout << (A == B ? "true\n" : "false\n");

@noindent@ @ return 0;@*
@}

@noindent ----------------------------end code block----------------------------

@noindent Output:@*
@ @ true@*
@ @ false

@node matrix operator<=>
@unnumberedsec operator<=>

@deftypefn {member} auto operator<=>(matrix const&) const
total ordering on matrix class
@end deftypefn

@noindent Example:

@noindent ------------------------------code block------------------------------

@noindent # include <iostream>@*
# include <vector>@*
# include <matrix.h>

@noindent int main(void)@*
@{@*
@ @ matrix A@{std::vector<std::uint32_t>@{2, 1@}, 5@};@*
@ @ matrix B@{std::vector<std::uint32_t>@{1, 2@}, 5@};@*
@ @ auto comp = (A <=> B);

@noindent @ @ if ( comp < 0 ) std::cout << "A < B";@*
@ @ else if ( comp == 0 ) std::cout << "A == B";@*
@ @ else std::cout << "A > B";

@noindent@ @ return 0;@*
@}

@noindent ----------------------------end code block----------------------------

@noindent Output:@*
@ @ A > B

@node matrix operator*=
@unnumberedsec operator*=

@deftypefn {member} matrix operator*=(matrix const&)
matrix-matrix assignment multiplication
@end deftypefn

@noindent Example:

@noindent ------------------------------code block------------------------------

@noindent # include <iostream>@*
# include <vector>@*
# include <matrix.h>

@noindent int main(void)@*
@{@*
@ @ matrix A@{std::vector<std::uint32_t>@{1, 2@}@};@*

@noindent @ @ std::cout << "A =\n";@*
@ @ A.print(std::cout);@*
@ @ std::cout << '\n';

@noindent @ @ A *= A;@*
@ @ std::cout << "A =\n";@*
@ @ A.print(std::cout);@*
@ @ std::cout << '\n';

@noindent@ @ return 0;@*
@}

@noindent ----------------------------end code block----------------------------

@noindent Output:@*
@ @ A =@*
@ @ 0 1@*
@ @ 1 0

@noindent @ @ A =@*
@ @ 1 0@*
@ @ 0 1

@node matrix print
@unnumberedsec print

@deftypefn {member} void print(std::ostream&) const
print matrix in standard/array form
@end deftypefn

@noindent Example:

@noindent ------------------------------code block------------------------------

@noindent # include <iostream>@*
# include <vector>@*
# include <matrix.h>

@noindent int main(void)@*
@{@*
@ @ matrix A@{std::vector<std::uint32_t>@{1, 2@}@};

@noindent @ @ std::cout << "A =\n";@*
@ @ A.print(std::cout);@*

@noindent@ @ return 0;@*
@}

@noindent ----------------------------end code block----------------------------

@noindent Output:@*
@ @ A =@*
@ @ 0 1@*
@ @ 1 0

@node matrix inverse
@unnumberedsec inverse

@deftypefn {member} matrix inverse() const
return inverse of @code{*this}
@end deftypefn

@noindent Example:

@noindent ------------------------------code block------------------------------

@noindent # include <iostream>@*
# include <vector>@*
# include <matrix.h>

@noindent int main(void)@*
@{@*
@ @ matrix A@{std::vector<std::uint32_t>@{3, 2@}@};@*
@ @ matrix B@{A.inverse()@};

@noindent @ @ std::cout << "A =\n";@*
@ @ A.print(std::cout);@*
@ @ std::cout << '\n';

@noindent @ @ std::cout << "B =\n";@*
@ @ B.print(std::cout);@*
@ @ std::cout << '\n';

@noindent@ @ return 0;@*
@}

@noindent ----------------------------end code block----------------------------

@noindent Output:@*
@ @ A =@*
@ @ 1 1@*
@ @ 1 0

@noindent @ @ B =@*
@ @ 0 1@*
@ @ 1 1

@node matrix gauss_form
@unnumberedsec gauss_form

@deftypefn {member} matrix gauss_form() const
return row echelon form
@end deftypefn

@noindent Example:

@noindent ------------------------------code block------------------------------

@noindent # include <iostream>@*
# include <vector>@*
# include <matrix.h>

@noindent int main(void)@*
@{@*
@ @ matrix A@{std::vector<std::uint32_t>@{1, 3@}@};@*
@ @ matrix B@{A.gauss_form()@};

@noindent @ @ std::cout << "A =\n";@*
@ @ A.print(std::cout);@*
@ @ std::cout << '\n';

@noindent @ @ std::cout << "B =\n";@*
@ @ B.print(std::cout);@*
@ @ std::cout << '\n';

@noindent@ @ return 0;@*
@}

@noindent ----------------------------end code block----------------------------

@noindent Output:@*
@ @ A =@*
@ @ 0 1@*
@ @ 1 1

@noindent @ @ B =@*
@ @ 1 1@*
@ @ 0 1

@node matrix rref
@unnumberedsec rref

@deftypefn {member} matrix rref() const
return reduced row echelon form
@end deftypefn

@noindent Example:

@noindent ------------------------------code block------------------------------

@noindent # include <iostream>@*
# include <vector>@*
# include <matrix.h>

@noindent int main(void)@*
@{@*
@ @ matrix A@{std::vector<std::uint32_t>@{1, 3@}@};@*
@ @ matrix B@{A.rref()@};

@noindent @ @ std::cout << "A =\n";@*
@ @ A.print(std::cout);@*
@ @ std::cout << '\n';

@noindent @ @ std::cout << "B =\n";@*
@ @ B.print(std::cout);@*
@ @ std::cout << '\n';

@noindent@ @ return 0;@*
@}

@noindent ----------------------------end code block----------------------------

@noindent Output:@*
@ @ A =@*
@ @ 0 1@*
@ @ 1 1

@noindent @ @ B =@*
@ @ 1 0@*
@ @ 0 1

@node matrix rank
@unnumberedsec rank

@deftypefn {member} std::size_t rank() const
return rank of matrix
@end deftypefn

@noindent Example:

@noindent ------------------------------code block------------------------------

@noindent # include <iostream>@*
# include <vector>@*
# include <matrix.h>

@noindent int main(void)@*
@{@*
@ @ matrix A@{std::vector<std::uint32_t>@{3, 3@}@};@*

@noindent @ @ std::cout << "rank = " << A.rank() << '\n';

@noindent@ @ return 0;@*
@}

@noindent ----------------------------end code block----------------------------

@noindent Output:@*
@ @ rank = 1

@node matrix row_space
@unnumberedsec row_space

@deftypefn {member} void row_space() const
print nonzero vectors in row space of @code{*this} (assumes full rank)
@end deftypefn

@noindent Example:

@noindent ------------------------------code block------------------------------

@noindent # include <iostream>@*
# include <vector>@*
# include <matrix.h>

@noindent int main(void)@*
@{@*
@ @ matrix A@{identity_matrix32(2)@};@*
@ @ A.row_space();

@noindent@ @ return 0;@*
@}

@noindent ----------------------------end code block----------------------------

@noindent Output:@*
@ @ 1 2 3

@node matrix shape
@unnumberedsec shape

@deftypefn {member} dimensions& shape() &
@deftypefnx {member} dimensions shape() &&
@deftypefnx {member} dimensions const& shape() const&
return row-column dimensions
@end deftypefn

@noindent Example:

@noindent ------------------------------code block------------------------------

@noindent # include <iostream>@*
# include <vector>@*
# include <matrix.h>

@noindent int main(void)@*
@{@*
@ @ matrix A@{2, 3@};@*
@ @ std::pair<std::size_t, std::size_t> dims@{A.shape()@};

@noindent @ @ std::cout << "number of rows = " << dims.first << '\n';@*
@ @ std::cout << "number of columns = " << dims.second << '\n';

@noindent@ @ return 0;@*
@}

@noindent ----------------------------end code block----------------------------

@noindent Output:@*
@ @ number of rows = 2@*
@ @ number of columns = 3

@node matrix nrows
@unnumberedsec nrows

@deftypefn {member} std::size_t& nrows() &
@deftypefnx {member} std::size_t nrows() &&
@deftypefnx {member} std::size_t const& nrows() const&
return number of rows
@end deftypefn

@noindent Example:

@noindent ------------------------------code block------------------------------

@noindent # include <iostream>@*
# include <vector>@*
# include <matrix.h>

@noindent int main(void)@*
@{@*
@ @ matrix A@{2, 3@};@*
@ @ std::cout << "number of rows = " << A.nrows() << '\n';

@noindent@ @ return 0;@*
@}

@noindent ----------------------------end code block----------------------------

@noindent Output:@*
@ @ number of rows = 2

@node matrix ncols
@unnumberedsec ncols

@deftypefn {member} std::size_t& ncols() &
@deftypefnx {member} std::size_t ncols() &&
@deftypefnx {member} std::size_t const& ncols() const&
return number of columns
@end deftypefn

@noindent Example:

@noindent ------------------------------code block------------------------------

@noindent # include <iostream>@*
# include <vector>@*
# include <matrix.h>

@noindent int main(void)@*
@{@*
@ @ matrix A@{2, 3@};@*
@ @ std::cout << "number of columns = " << A.ncols() << '\n';

@noindent@ @ return 0;@*
@}

@noindent ----------------------------end code block----------------------------

@noindent Output:@*
@ @ number of columns = 2

@node matrix resize
@unnumberedsec resize

@deftypefn {member} void resize(std::size_t n)
resize matrix to n x n
@end deftypefn

@deftypefn {member} void resize(std::size_t n, std::size_t m)
resize matrix to n x m
@end deftypefn

@noindent Example:

@noindent ------------------------------code block------------------------------

@noindent # include <iostream>@*
# include <vector>@*
# include <matrix.h>

@noindent int main(void)@*
@{@*
@ @ matrix A@{2, 3@};@*
@ @ std::pair<std::size_t, std::size_t> dims@{A.shape()@};

@noindent @ @ std::cout << "number of rows = " << dims.first << '\n';@*
@ @ std::cout << "number of columns = " << dims.second << "\n\n";

@noindent @ @ A.resize(2);@*
@ @ dims = A.shape();@*
@ @ std::cout << "number of rows = " << dims.first << '\n';@*
@ @ std::cout << "number of columns = " << dims.second << '\n';

@noindent@ @ return 0;@*
@}

@noindent ----------------------------end code block----------------------------

@noindent Output:@*
@ @ number of rows = 2@*
@ @ number of columns = 3

@noindent @ @ number of rows = 2@*
@ @ number of columns = 2

@node matrix assignment
@unnumberedsec assignment

@deftypefn {member} matrix& operator=(matrix &&) & noexcept = default
@deftypefnx {member} matrix& operator=(matrix const&) & = default
matrix assignment operation
@end deftypefn

@node matrix constructors/destructor
@unnumberedsec constructors/destructor

@deffn {member} matrix() = default
@deffnx {member} matrix(matrix const&) = default
@deffnx {member} matrix(matrix &&) noexcept = default
@deffnx {member} explicit matrix(container const&)
@deffnx {member} explicit matrix(container &&)
@deffnx {member} matrix(container const&, std::size_t)
@deffnx {member} matrix(container &&, std::size_t)
@deffnx {member} explicit matrix(std::size_t)
@deffnx {member} matrix(std::size_t, std::size_t)
matrix constructors
@end deffn

@deffn {member} ~matrix() = default
matrix destructor
@end deffn

@raisesections

@node ag.h
@section ag.h

@menu
Friend Functions:
* ag operator<<:: output container
* ag operator>>:: input container
* ag operator*:: multiplicative arithmetic
* ag operator==:: check spreads for equality
* ag operator<:: total ordering on spreads
* ag orthogoval:: check if two spreads are orthogoval

Member Functions:
* ag print:: print matrix in standard/array form
* ag resize:: resize matrix to new dimensions
* ag assignment:: assigning spreads
* ag constructors/destructor:: constructing and destructing spreads
@end menu

@lowersections

@node ag operator<<
@unnumberedsec operator<<

@deftypefn {friend} std::ostream& operator<<(std::ostream&, AG const&)
output container
@end deftypefn

@noindent Example:

@noindent ------------------------------code block------------------------------

@noindent # include <iostream>@*
# include <ag.h>

@noindent int main(void)@*
@{@*
@ @ AG A@{2, 3@};@*

@noindent @ @ std::cout << A;

@noindent@ @ return 0;@*
@}

@noindent ----------------------------end code block----------------------------

@noindent Output:@*
@ @ 0 0 0@*
@ @ 0 0 0@*

@node ag operator>>
@unnumberedsec operator>>

@deftypefn {friend} std::istream& operator>>(std::istream&, AG&)
input container
@end deftypefn

@noindent Example:

@noindent ------------------------------code block------------------------------

@noindent # include <iostream>@*
# include <ag.h>

@noindent int main(void)@*
@{@*
@ @ AG A@{2, 3@};@*

@noindent @ @ std::cin >> A;@*
@ @ std::cout << A;

@noindent@ @ return 0;@*
@}

@noindent ----------------------------end code block----------------------------

@noindent Input:@*
@ @ 1 2 3@*
@ @ 4 5 6

@noindent Output:@*
@ @ 1 2 3@*
@ @ 4 5 6

@node ag operator*
@unnumberedsec operator*

@deftypefn {friend} AG operator*(matrix const&, AG const&)
apply matrix/linear transform to each space in spread
@end deftypefn

@noindent Example:

@noindent ------------------------------code block------------------------------

@noindent # include <iostream>@*
# include <ag.h>@*
# include <matrix.h>

@noindent int main(void)@*
@{@*
@ @ AG A1@{2, 3@};@*

@noindent @ @ std::cin >> A1;@*
@ @ std::cout << "A1 =\n" << A1 << '\n';

@noindent @ @ matrix B@{std::vector<std::uint32_t>@{2, 0, 0@}@};@*
@ @ std::cout << "B =\n";@*
@ @ B.print(std::cout);@*
@ @ std::cout << '\n';

@noindent @ @ AG A2@{B * A1@};@*
@ @ std::cout << "A2 =\n" << A2;

@noindent @ @ return 0;@*
@}

@noindent ----------------------------end code block----------------------------

@noindent Input:@*
@ @ 1 2 3@*
@ @ 4 5 6

@noindent Output:@*
@ @ A1 =@*
@ @ 1 2 3@*
@ @ 4 5 6

@noindent @ @ B =@*
@ @ 0 1 0@*
@ @ 0 0 0@*
@ @ 0 0 0@*

@noindent @ @ A2 =@*
@ @ 0 4 4@*
@ @ 0 0 4

@node ag operator==
@unnumberedsec operator==

@deftypefn {friend} bool operator==(AG const&, AG const&)
check spreads for equality
@end deftypefn

@noindent Example:

@noindent ------------------------------code block------------------------------

@noindent # include <iostream>@*
# include <ag.h>@*

@noindent int main(void)@*
@{@*
@ @ AG A1@{2, 3@}, A2@{2, 3@};@*

@noindent @ @ std::cin >> A1 >> A2;@*
@ @ std::cout << (A1 == A1 ? "true\n" : "false\n");@*
@ @ std::cout << (A1 == A2 ? "true\n" : "false\n");

@noindent @ @ return 0;@*
@}

@noindent ----------------------------end code block----------------------------

@noindent Input:@*
@ @ 1 2 3 4 5 6@*
@ @ 2 3 4 5 6 7

@noindent Output:@*
@ @ true@*
@ @ false

@node ag operator<
@unnumberedsec operator<

@deftypefn {friend} bool operator<(AG const&, AG const&)
total ordering on spreads
@end deftypefn

@noindent Example:

@noindent ------------------------------code block------------------------------

@noindent # include <iostream>@*
# include <ag.h>@*

@noindent int main(void)@*
@{@*
@ @ AG A1@{2, 3@}, A2@{2, 3@};@*

@noindent @ @ std::cin >> A1 >> A2;@*
@ @ std::cout << (A1 < A1 ? "true\n" : "false\n");@*
@ @ std::cout << (A1 < A2 ? "true\n" : "false\n");

@noindent @ @ return 0;@*
@}

@noindent ----------------------------end code block----------------------------

@noindent Input:@*
@ @ 1 2 3 4 5 6@*
@ @ 2 3 4 5 6 7

@noindent Output:@*
@ @ false@*
@ @ true

@node ag orthogoval
@unnumberedsec orthogoval

@deftypefn {friend} bool orthogoval(AG const&, AG const&)
check if two spreads are orthogoval
@end deftypefn

@noindent Example:

@noindent ------------------------------code block------------------------------

@noindent # include <iostream>@*
# include <ag.h>@*

@noindent int main(void)@*
@{@*
@ @ AG A1@{5, 4@}, A2@{5, 4@};@*

@noindent @ @ std::cin >> A1 >> A2;@*
@ @ std::cout << (orthogoval(A1, A2) ? "true\n" : "false\n");

@noindent @ @ return 0;@*
@}

@noindent ----------------------------end code block----------------------------

@noindent Input:@*
@ @ 0 1 6 7 0 2 12 14 0 4 11 15 0 8 5 13 0 3 10 9@*
@ @ 0 1 2 3 0 4 10 14 0 5 9 12 0 6 11 13 0 7 8 15

@noindent Output:@*
@ @ true@*

@node ag print
@unnumberedsec print

@deftypefn {member} void print() const
print matrix in standard/array form
@end deftypefn

@noindent Example:

@noindent ------------------------------code block------------------------------

@noindent # include <iostream>@*
# include <ag.h>@*

@noindent int main(void)@*
@{@*
@ @ AG A1@{2, 4@};

@noindent @ @ std::cin >> A1;@*
@ @ A1.print();

@noindent @ @ return 0;@*
@}

@noindent ----------------------------end code block----------------------------

@noindent Input:@*
@ @ 0 1 6 7 0 2 12 14

@noindent Output:@*
@ @ 0 0 0 0@*
@ @ 0 0 0 1@*
@ @ 0 1 1 0@*
@ @ 0 1 1 1

@noindent @ @ 0 0 0 0@*
@ @ 0 0 1 0@*
@ @ 1 1 0 0@*
@ @ 1 1 1 0

@node ag resize
@unnumberedsec resize

@deftypefn {member} void resize(std::size_t, std::size_t)
resize matrix to new dimensions
@end deftypefn

@noindent Example:

@noindent ------------------------------code block------------------------------

@noindent # include <iostream>@*
# include <ag.h>@*

@noindent int main(void)@*
@{@*
@ @ AG A1@{2, 4@};

@noindent @ @ std::cin >> A1;@*
@ @ std::cout << A1 << '\n';

@noindent @ @ A1.resize(3, 4);@*
@ @ std::cout << A1;

@noindent @ @ return 0;@*
@}

@noindent ----------------------------end code block----------------------------

@noindent Input:@*
@ @ 0 1 6 7 0 2 12 14

@noindent Output:@*
@ @ 0 1 6 7@*
@ @ 0 2 12 14

@noindent @ @ 0 1 6 7@*
@ @ 0 2 12 14@*
@ @ 0 0 0 0

@node ag assignment
@unnumberedsec assignment

@deftypefn {member} AG& operator=(AG &&) & noexcept = default
@deftypefnx {member} AG& operator=(AG const&) & = default
assigning spreads
@end deftypefn

@node ag constructors/destructor
@unnumberedsec constructors/destructor

@deffn {member} AG() = default
@deffnx {member} AG(AG const&) = default
@deffnx {member} AG(AG &&) noexcept = default
@deffnx {member} AG(std::size_t, std::size_t)
AG constructors
@end deffn

@deffn {member} ~AG() = default
AG destructor
@end deffn

@raisesections

@node Sec 4
@chapter Executable Documentation

There are five executables included in this package:

@menu

* transversal:: calculate orbit of canonical spread
* automorphisms:: calculate orbit and autorphism group of canonical spread
* mutually_orthogoval:: find maximal sets of mutually orthogoval sets via clique search
* feasible_coverings:: find maximal sets of mutually orthogoval sets via exact cover search
* feasible_subspaces:: find all subspaces capable of forming a spread orthogoval to the canonical spread

@end menu

@node transversal
@unnumberedsec transversal

The executable @code{transversal} is used to find all the spreads which
are orthogoval to the canonical spread @code{L}. The orbit of @code{L}
under the natural action of @code{GL(n, q)} is calculated. As each
distinct isomorphic copy of @code{L} is found, it is tested for whether
it is orthogoval to @code{L}. If it is, it is printed to @code{stdout}.
The total number of orthogoval isomorphic copies of @code{L} are printed
at the conclusion of the execution.

@noindent Usage:

@noindent From the top of the build directory, run

@code{./src/transversal <degree> <order> <canonical_spread_file>}

@noindent The parameters are as follows:

@itemize
@item @code{<degree>} -- degree of the canonical spread
@item @code{<order>} -- order of the canonical spread
@item @code{canonical_spread_file} -- the canonical spread is stored in this file and can be generated by the Bourne script @code{canonical_spread.sh} in the directory @code{data}
@end itemize

@node automorphisms
@unnumberedsec automorphisms

The executable @code{automorphisms} is used to find all the spreads
which are orthogoval to the canonical spread @code{L}. The orbit of
@code{L} under the natural action of @code{GL(n, q)} is calculated. In
addition, the automorphism group of @code{L} is calculated and printed
to the file @code{automorphisms.txt}, a transversal for the action is
printed to @code{transversal.txt}, the transversal elements giving
orthogoval isomorphic copies of @code{L} are printed to
@code{orthogoval_transversal.txt}, the orthogoval isomorphic copies of
@code{L} are printed to @code{vertices.txt}.

@noindent Usage:

@noindent From the top of the build directory, run

@code{./src/automorphisms <degree> <order> <canonical_spread_file>}

@noindent The parameters are as follows:

@itemize
@item @code{<degree>} -- degree of the canonical spread
@item @code{<order>} -- order of the canonical spread
@item @code{canonical_spread_file} -- the canonical spread is stored in this file and can be generated by the Bourne script @code{canonical_spread.sh} in the directory @code{data}
@end itemize

@node mutually_orthogoval
@unnumberedsec mutually_orthogoval

Let @code{L} be the canonical line spread, and suppose the orthogoval
isomorphic copies of @code{L} have been stored in the file
@code{vertices.txt} (say, using executables @code{transversal} or
@code{automorphisms} included in this package). The executable
@code{mutually_orthogoval} generates a graph using these isomorphic
copies as vertices with the symmetric relation given by orthogovalility.
@code{Cliquer} is then used to search for cliques in this graph, which
amount to sets of mutually orthogoval planes containing @code{L}.

@noindent Usage:

@noindent From the top of the build directory, run

@code{./src/mutually_orthogoval <nvertices> <order>}

@noindent The vertices are read from @code{stdin}. The cliques are output to
@code{stdout} The parameters are as follows:

@itemize
@item @code{<nvertices>} -- the number of orthogoval isomorphic copies of @code{L} contained in the file @code{vertices.txt}
@item @code{<order>} -- the order of the canonical line spread @code{L}
@end itemize

@node feasible_coverings
@unnumberedsec feasible_coverings

The executable @code{feasible_coverings} takes the nonzero vectors of
the feasible subspaces generated by the executable
@code{feasible_subspaces} and performs Knuth's Algorithm X for exact
covers to find maximal sets of mutually orthogoval affine planes
containing the canonical line spread.

@noindent Usage:

@noindent From the top of the build directory, run

@code{./src/feasible_coverings <nitems> <noptions> <optsize>}

@noindent The options (feasible subspaces) are read from @code{stdin}. The
coverings are written to @code{stdout}. The parameters are as follows:

@itemize
@item @code{<nitems>} -- number of nonzero vectors in the ambient vector space
@item @code{<noptions>} -- number of feasible subspaces
@item @code{<optsize>} -- number of nozero vectors in feasible subspace
@end itemize

@node feasible_subspaces
@unnumberedsec feasible_subspaces

Let @code{L} be the canonical spread. The executable
@code{feasible_subspaces} generates all those subspaces of the
appropriate size which intersect each subspace contained in @code{L} in
a space of dimension at most 1.

@noindent Usage:

@noindent From the top of the build directory, run

@code{./src/feasible_subspaces <degree>}

@noindent Bases for the canonical spread are read from @code{stdin} and can be
generated by the script @code{spread_basis.sh} contained in the @code{data}
directory. The feasible subspaces are written to @code{stdout}. From the top of the
build directory run

@code{./src/feasible_subspaces <2degree>}

The parameters are as follows:

@itemize
@item @code{<2degree>} -- twice the degree of the canonical spread
@end itemize

@node Sec 5
@chapter GNU Free Documentation License

@menu

* Subsec 1:: PREAMBLE
* Subsec 2:: APPLICABILITY AND DEFINITIONS
* Subsec 3:: VERBATIM COPYING
* Subsec 4:: COPYING IN QUANTITY
* Subsec 5:: MODIFICATIONS
* Subsec 6:: COMBINING DOCUMENTS
* Subsec 7:: COLLECTIONS OF DOCUMENTS
* Subsec 8:: AGGREGATION WITH INDEPENDENT WORKS
* Subsec 9:: TRANSLATION
* Subsec 10:: TERMINATION
* Subsec 11:: FUTURE REVISIONS OF THIS LICENSE
* Subsec 12:: RELICENSING

@end menu

@node Subsec 1
@section PREAMBLE

The purpose of this License is to make a manual, textbook, or other functional and
useful document free in the sense of freedom: to assure everyone the effective
freedom to copy and redistribute it, with or without modifying it, either
commercially or noncommercially. Secondarily, this License preserves for the author
and publisher a way to get credit for their work, while not being considered
responsible for modifications
made by others.

This License is a kind of “copyleft”, which means that derivative works of the
document must themselves be free in the same sense. It complements the GNU General
Public License, which is a copyleft license designed for free software.

We have designed this License in order to use it for manuals for free software,
because free software needs free documentation: a free program should come with
manuals providing the same freedoms that the software does. But this License is not
limited to software manuals; it can be used for any textual work, regardless of
subject matter or whether it is published as a printed book. We recommend this
License principally for works whose purpose is instruction or reference.

@node Subsec 2
@section APPLICABILITY AND DEFINITIONS

This License applies to any manual or other work, in any medium, that contains a
notice placed by the copyright holder saying it can be distributed under the terms
of this License. Such a notice grants a world-wide, royalty-free license, unlimited
in duration, to use that work under the conditions stated herein. The “Document”,
below, refers to any such manual or work. Any member of the public is a licensee,
and is addressed as “you”. You accept the license if you copy, modify or distribute
the work in a way requiring permission under copyright law.

A “Modified Version” of the Document means any work containing the Document or
a portion of it, either copied verbatim, or with modifications and/or translated
into another language.

A “Secondary Section” is a named appendix or a front-matter section of the Document
that deals exclusively with the relationship of the publishers or authors of the
Document to the Document’s overall subject (or to related matters) and contains
nothing that could fall directly within that overall subject. (Thus, if the
Document is in part a textbook of mathematics, a Secondary Section may not explain
any mathematics.) The relationship could be a matter of historical connection with
the subject or with related matters, or of legal, commercial, philosophical,
ethical or political position regarding them.

The “Invariant Sections” are certain Secondary Sections whose titles are
designated, as being those of Invariant Sections, in the notice that says that the
Document is released Appendix G: GNU Free Documentation License 300 under this
License. If a section does not fit the above definition of Secondary then it is not
allowed to be designated as Invariant. The Document may contain zero Invariant
Sections. If the Document does not identify any Invariant Sections then there are
none.

The “Cover Texts” are certain short passages of text that are listed, as
Front-Cover Texts or Back-Cover Texts, in the notice that says that the Document is
released under this License. A Front-Cover Text may be at most 5 words, and a
Back-Cover Text may be at most 25 words.

A “Transparent” copy of the Document means a machine-readable copy, represented in
a format whose specification is available to the general public, that is suitable
for revising the document straightforwardly with generic text editors or (for
images composed of pixels) generic paint programs or (for drawings) some widely
available drawing editor, and that is suitable for input to text formatters or for
automatic translation to a variety of formats suitable for input to text
formatters. A copy made in an otherwise Transparent file format whose markup, or
absence of markup, has been arranged to thwart or discourage subsequent
modification by readers is not Transparent. An image format is not Transparent if
used for any substantial amount of text. A copy that is not “Transparent” is called
“Opaque”.

Examples of suitable formats for Transparent copies include plain ASCII without
markup, Texinfo input format, LaTEX input format, SGML or XML using a publicly
available DTD, and standard-conforming simple HTML, PostScript or PDF designed
for human modification. Examples of transparent image formats include PNG, XCF
and JPG. Opaque formats include proprietary formats that can be read and edited
only by proprietary word processors, SGML or XML for which the DTD and/or
processing tools are not generally available, and the machine-generated HTML,
PostScript or PDF produced by some word processors for output purposes only.

The “Title Page” means, for a printed book, the title page itself, plus such
following pages as are needed to hold, legibly, the material this License requires
to appear in the title page. For works in formats which do not have any title page
as such, “Title Page” means the text near the most prominent appearance of the
work’s title, preceding the beginning of the body of the text.

The “publisher” means any person or entity that distributes copies of the Document
to the public.

A section “Entitled XYZ” means a named subunit of the Document whose title either
is precisely XYZ or contains XYZ in parentheses following text that translates XYZ
in another language. (Here XYZ stands for a specific section name mentioned below,
such as “Acknowledgements”, “Dedications”, “Endorsements”, or “History”.) To
“Preserve the Title” of such a section when you modify the Document means that it
remains a section “Entitled XYZ” according to this definition.

The Document may include Warranty Disclaimers next to the notice which states that
this License applies to the Document. These Warranty Disclaimers are considered to
be included by reference in this License, but only as regards disclaiming
warranties: any other implication that these Warranty Disclaimers may have is void
and has no effect on the meaning of this License.

@node Subsec 3
@section VERBATIM COPYING

You may copy and distribute the Document in any medium, either commercially or
noncommercially, provided that this License, the copyright notices, and the license
notice saying this License applies to the Document are reproduced in all copies,
and that you add no other conditions whatsoever to those of this License. You may
not use technical measures to obstruct or control the reading or further copying of
the copies you make or distribute. However, you may accept compensation in exchange
for copies. If you distribute a large enough number of copies you must also follow
the conditions in section 3.

You may also lend copies, under the same conditions stated above, and you may
publicly display copies.

@node Subsec 4
@section COPYING IN QUANTITY

If you publish printed copies (or copies in media that commonly have printed
covers) of the Document, numbering more than 100, and the Document’s license notice
requires Cover Texts, you must enclose the copies in covers that carry, clearly and
legibly, all these Cover Texts: Front-Cover Texts on the front cover, and
Back-Cover Texts on the back cover. Both covers must also clearly and legibly
identify you as the publisher of these copies. The front cover must present the
full title with all words of the title equally prominent and visible. You may add
other material on the covers in addition. Copying with changes limited to the
covers, as long as they preserve the title of the Document and satisfy these
conditions, can be treated as verbatim copying in other respects.

If the required texts for either cover are too voluminous to fit legibly, you
should put the first ones listed (as many as fit reasonably) on the actual cover,
and continue the rest onto adjacent pages.

If you publish or distribute Opaque copies of the Document numbering more than 100,
you must either include a machine-readable Transparent copy along with each Opaque
copy, or state in or with each Opaque copy a computer-network location from which
the general network-using public has access to download using public-standard
network protocols a complete Transparent copy of the Document, free of added
material. If you use the latter option, you must take reasonably prudent steps,
when you begin distribution of Opaque copies in quantity, to ensure that this
Transparent copy will remain thus accessible at the stated location until at least
one year after the last time you distribute an Opaque copy (directly or through
your agents or retailers) of that edition to the public.

It is requested, but not required, that you contact the authors of the Document
well before redistributing any large number of copies, to give them a chance to
provide you with an updated version of the Document.

@node Subsec 5
@section MODIFICATIONS

You may copy and distribute a Modified Version of the Document under the conditions
of sections 2 and 3 above, provided that you release the Modified Version under
precisely this License, with the Modified Version filling the role of the Document,
thus licensing distribution and modification of the Modified Version to whoever
possesses a copy of it. In addition, you must do these things in the Modified
Version:

@enumerate
@item
Use in the Title Page (and on the covers, if any) a title distinct from that of the
Document, and from those of previous versions (which should, if there were any, be
listed in the History section of the Document). You may use the same title as a
previous version if the original publisher of that version gives permission.

@item
List on the Title Page, as authors, one or more persons or entities responsible for
authorship of the modifications in the Modified Version, together with at least
five of the principal authors of the Document (all of its principal authors, if it
has fewer than five), unless they release you from this requirement.

@item
State on the Title page the name of the publisher of the Modified Version, as the
publisher.

@item
Preserve all the copyright notices of the Document.

@item
Add an appropriate copyright notice for your modifications adjacent to the other
copyright notices.

@item
Include, immediately after the copyright notices, a license notice giving the
public permission to use the Modified Version under the terms of this License, in
the form shown in the Addendum below.

@item
Preserve in that license notice the full lists of Invariant Sections and required
Cover Texts given in the Document’s license notice.

@item
Include an unaltered copy of this License.

@item
Preserve the section Entitled “History”, Preserve its Title, and add to it an item
stating at least the title, year, new authors, and publisher of the Modified
Version as given on the Title Page. If there is no section Entitled “History” in
the Document, create one stating the title, year, authors, and publisher of the
Document as given on its Title Page, then add an item describing the Modified
Version as stated in the previous sentence.

@item
Preserve the network location, if any, given in the Document for public access to
a Transparent copy of the Document, and likewise the network locations given in
the Document for previous versions it was based on. These may be placed in the
“History” section. You may omit a network location for a work that was published
at least four years before the Document itself, or if the original publisher of the
version it refers to gives permission.

@item
For any section Entitled “Acknowledgements” or “Dedications”, Preserve the Title
of the section, and preserve in the section all the substance and tone of each of
the contributor acknowledgements and/or dedications given therein.

@item
Preserve all the Invariant Sections of the Document, unaltered in their text and
in their titles. Section numbers or the equivalent are not considered part of the
section titles.

@item
Delete any section Entitled “Endorsements”. Such a section may not be included
in the Modified Version.

@item
Do not retitle any existing section to be Entitled “Endorsements” or to conflict in
title with any Invariant Section.

@item
Preserve any Warranty Disclaimers.

@end enumerate

@node Subsec 6
@section COMBINING DOCUMENTS

You may combine the Document with other documents released under this License,
under the terms defined in section 4 above for modified versions, provided that you
include in the combination all of the Invariant Sections of all of the original
documents, unmodified, and list them all as Invariant Sections of your combined
work in its license notice, and that you preserve all their Warranty Disclaimers.

The combined work need only contain one copy of this License, and multiple
identical Invariant Sections may be replaced with a single copy. If there are
multiple Invariant Sections with the same name but different contents, make the
title of each such section unique by adding at the end of it, in parentheses, the
name of the original author or publisher of that section if known, or else a unique
number. Make the same adjustment to the section titles in the list of Invariant
Sections in the license notice of the combined work.

In the combination, you must combine any sections Entitled “History” in the various
original documents, forming one section Entitled “History”; likewise combine any
sections Entitled “Acknowledgements”, and any sections Entitled “Dedications”. You
must delete all sections Entitled “Endorsements.”

@node Subsec 7
@section COLLECTIONS OF DOCUMENTS

You may make a collection consisting of the Document and other documents released
under this License, and replace the individual copies of this License in the
various documents with a single copy that is included in the collection, provided
that you follow the rules of this License for verbatim copying of each of the
documents in all other respects.

You may extract a single document from such a collection, and distribute it
individually under this License, provided you insert a copy of this License into
the extracted document, and follow this License in all other respects regarding
verbatim copying of that document.

@node Subsec 8
@section AGGREGATION WITH INDEPENDENT WORKS

A compilation of the Document or its derivatives with other separate and
independent documents or works, in or on a volume of a storage or distribution
medium, is called an “aggregate” if the copyright resulting from the compilation is
not used to limit the legal rights of the compilation’s users beyond what the
individual works permit. When the Document is included in an aggregate, this
License does not apply to the other works in the aggregate which are not themselves
derivative works of the Document.

If the Cover Text requirement of section 3 is applicable to these copies of the
Document, then if the Document is less than one half of the entire aggregate, the
Document’s Cover Texts may be placed on covers that bracket the Document within the
aggregate, or the electronic equivalent of covers if the Document is in electronic
form. Otherwise they must appear on printed covers that bracket the whole
aggregate.

@node Subsec 9
@section TRANSLATION

Translation is considered a kind of modification, so you may distribute
translations of the Document under the terms of section 4. Replacing Invariant
Sections with translations requires special permission from their copyright
holders, but you may include translations of some or all Invariant Sections in
addition to the original versions of these Invariant Sections. You may include a
translation of this License, and all the license notices in the Document, and any
Warranty Disclaimers, provided that you also include the original English version
of this License and the original versions of those notices and disclaimers. In case
of a disagreement between the translation and the original version of this License
or a notice or disclaimer, the original version will prevail.

If a section in the Document is Entitled “Acknowledgements”, “Dedications”, or
“History”, the requirement (section 4) to Preserve its Title (section 1) will
typically require changing the actual title.

@node Subsec 10
@section TERMINATION

You may not copy, modify, sublicense, or distribute the Document except as
expressly provided under this License. Any attempt otherwise to copy, modify,
sublicense, or distribute it is void, and will automatically terminate your rights
under this License.

However, if you cease all violation of this License, then your license from a
particular copyright holder is reinstated (a) provisionally, unless and until the
copyright holder explicitly and finally terminates your license, and (b)
permanently, if the copyright holder fails to notify you of the violation by some
reasonable means prior to 60 days after the cessation.

Moreover, your license from a particular copyright holder is reinstated permanently
if the copyright holder notifies you of the violation by some reasonable means,
this is the first time you have received notice of violation of this License (for
any work) from that copyright holder, and you cure the violation prior to 30 days
after your receipt of the notice.

Termination of your rights under this section does not terminate the licenses of
parties who have received copies or rights from you under this License. If your
rights have been terminated and not permanently reinstated, receipt of a copy of
some or all of the same material does not give you any rights to use it.

@node Subsec 11
@section FUTURE REVISIONS OF THIS LICENSE

The Free Software Foundation may publish new, revised versions of the GNU Free
Documentation License from time to time. Such new versions will be similar in
spirit to the present version, but may differ in detail to address new problems or
concerns. See https://www.gnu.org/licenses/.

Each version of the License is given a distinguishing version number. If the
Document specifies that a particular numbered version of this License “or any later
version” applies to it, you have the option of following the terms and conditions
either of that specified version or of any later version that has been published
(not as a draft) by the Free Software Foundation. If the Document does not specify
a version number of this License, you may choose any version ever published (not as
a draft) by the Free Software Foundation. If the Document specifies that a proxy
can decide which future versions of this License can be used, that proxy’s public
statement of acceptance of a version permanently authorizes you to choose that
version for the Document.

@node Subsec 12
@section RELICENSING

“Massive Multiauthor Collaboration Site” (or “MMC Site”) means any World Wide
Web server that publishes copyrightable works and also provides prominent
facilities for anybody to edit those works. A public wiki that anybody can edit is
an example of such a server. A “Massive Multiauthor Collaboration” (or “MMC”)
contained in the site means any set of copyrightable works thus published on the
MMC site.

“CC-BY-SA” means the Creative Commons Attribution-Share Alike 3.0 license published
by Creative Commons Corporation, a not-for-profit corporation with a principal
place of business in San Francisco, California, as well as future copyleft versions
of that license published by that same organization.

“Incorporate” means to publish or republish a Document, in whole or in part, as
part of another Document.

An MMC is “eligible for relicensing” if it is licensed under this License, and if
all works that were first published under this License somewhere other than this
MMC, and subsequently incorporated in whole or in part into the MMC, (1) had no
cover texts or invariant sections, and (2) were thus incorporated prior to November
1, 2008.

The operator of an MMC Site may republish an MMC contained in the site under
CC-BY-SA on the same site at any time before August 1, 2009, provided the MMC is
eligible for relicensing.

@bye
