This is orthogoval.info, produced by makeinfo version 6.8 from
orthogoval.texi.

Copyright (C) 2025 Thomas Pender.

     Permission is granted to copy, distribute and/or modify this
     document under the terms of the GNU Free Documentation License,
     Version 1.3 or any later version published by the Free Software
     Foundation; with no Invariant Sections, no Front-Cover Texts, and
     no Back-Cover Texts.  A copy of the license is included in the
     section entitled "GNU Free Documentation License."


File: orthogoval.info,  Node: Top,  Next: Sec 1,  Up: (dir)

Mutually Orthogoval Affine Planes 0.0
*************************************

The package contains exectuables to search for maximal sets of mutually
orthogoval translation affine planes of even order.

* Menu:


* Sec 1:: Synopsis
* Sec 2:: Compilation and Installation
* Sec 3:: Class Documentation
* Sec 4:: Executable Documentation
* Sec 5:: GNU Free Documentation License

   Copyright (C) 2025 Thomas Pender.

     Permission is granted to copy, distribute and/or modify this
     document under the terms of the GNU Free Documentation License,
     Version 1.3 or any later version published by the Free Software
     Foundation; with no Invariant Sections, no Front-Cover Texts, and
     no Back-Cover Texts.  A copy of the license is included in the
     section entitled "GNU Free Documentation License."


File: orthogoval.info,  Node: Sec 1,  Next: Sec 2,  Prev: Top,  Up: Top

1 Synopsis
**********

hello world


File: orthogoval.info,  Node: Sec 2,  Next: Sec 3,  Prev: Sec 1,  Up: Top

2 Compilation and Installation
******************************

  1. Download and unpack the tarball.
  2. From the root directory of the project, create the build directory
     and move there with 'mkdir build && cd build'.
  3. Configure with '../configure'.  The optimizations can be adjusted
     by running instead '../configure CFLAGS="-O3"'.
  4. Compile with 'make'.  The executables are contained in the 'src'
     subdirectory of the 'build' directory created in step 2.


File: orthogoval.info,  Node: Sec 3,  Next: Sec 4,  Prev: Sec 2,  Up: Top

3 Class Documentation
*********************

There are two classes in this project:

* Menu:


* matrix.h:: A boolean matrix class.
* ag.h:: A boolean spread class.


File: orthogoval.info,  Node: matrix.h,  Next: ag.h,  Up: Sec 3

3.1 matrix.h
============

* Menu:

Class Types:
   * 'typedef typename std::pair<std::size_t, std::size_t> dimensions'
   * 'typedef typename std::vector<std::uint32_t> container'
   * 'typedef typename container::iterator iterator'
   * 'typedef typename container::const_iterator const_iterator'

Friend Functions:
* matrix operator<<:: output container
* matrix operator>>:: input container
* matrix operator*:: multiplicative arithmetic

Element Access:
* matrix operator[]:: row access
* matrix data:: return container
* matrix at:: entry access

Member Functions:
* matrix transpose:: return transpose of '*this'
* matrix operator==:: check equality between matrices
* matrix operator<=>:: total ordering on matrix class
* matrix operator*=:: assigmment matrix-matrix multiplication
* matrix print:: print matrix in standard/array form
* matrix inverse:: return inverse of '*this'
* matrix gauss_form:: return row echelon form
* matrix rref:: return reduced row echelon form
* matrix rank:: return rank of matrix
* matrix row_space:: print nonzero vectors in row space (assumes full rank)
* matrix shape:: return row-column dimensions
* matrix nrows:: return number of rows
* matrix ncols:: return number of columns
* matrix resize:: resize matrix to new dimensions
* matrix assignment:: assigning matrices
* matrix constructors/destructor:: constructing and destructing matrices


File: orthogoval.info,  Node: matrix operator<<,  Next: matrix operator>>,  Up: matrix.h

operator<<
----------

 -- friend: std::ostream& operator<<(std ::ostream&, matrix const&)
     output integer value of each row of matrix

Example:

--------------------code block--------------------

# include <iostream>
# include <vector>
# include <matrix.h>

int main(void)
{
  matrix A{std::vector<std::uint32_t>{1, 2}, 5};

  std::cout << A << '\n';

  return 0;
}

-------------------end code block-------------------

Output:
  1 2


File: orthogoval.info,  Node: matrix operator>>,  Next: matrix operator*,  Prev: matrix operator<<,  Up: matrix.h

operator>>
----------

 -- friend: std::istream& operator>>(std::istream&, matrix&)
     input container

Example:

--------------------code block--------------------

# include <iostream>
# include <matrix.h>

int main(void)
{
  matrix A{2, 5};

  std::cin >> A;
  A.print(std::cout);

  return 0;
}

-------------------end code block-------------------

Input:
  1 2

Output:
  0 0 0 0 1
  0 0 0 1 0


File: orthogoval.info,  Node: matrix operator*,  Next: matrix operator[],  Prev: matrix operator>>,  Up: matrix.h

operator*
---------

 -- friend: matrix operator*(matrix const&, matrix const&)
     matrix-matrix multiplication

 -- friend: std::uint32_t operator*(matrix const&, std::uint32_t)
     matrix-vector multiplication

 -- friend: std::uint32_t operator*(std::uint32_t, matrix const&)
     vector-matrix multiplication

Example:

--------------------code block--------------------

# include <iostream>
# include <vector>
# include <matrix.h>

int main(void)
{
  std::uint32_t v{1}, u{};
  matrix A{std::vector<std::uint32_t>{2, 1}, 5};
  matrix B{std::vector<std::uint32_t>{1, 2}, 2};

  std::cout << "A =\n";
  A.print(std::cout);
  std::cout << "\n\n";

  std::cout << "B =\n";
  B.print(std::cout);
  std::cout << "\n\n";

  matrix C{B * A};
  std::cout << "C =\n";
  C.print(std::cout);
  std::cout << "\n\n";

  u = A * v;
  std::cout << "u = " << u << '\n';

  u = v * B;
  std::cout << "u = " << u << '\n';

  return 0;
}

-------------------end code block-------------------

Output:
  A =
  0 0 0 1 0
  0 0 0 0 1

  B =
  0 1
  1 0

  C =
  0 0 0 0 1
  0 0 0 1 0

  u = 1
  u = 2


File: orthogoval.info,  Node: matrix operator[],  Next: matrix data,  Prev: matrix operator*,  Up: matrix.h

operator[]
----------

 -- member: std::uint32_t& operator[](std::size_t) &
 -- member: std::uint32_t operator[](std::size_t) &&
 -- member: std::uint32_t const& operator[](std::size_t) const&
     row access

Example:

--------------------code block--------------------

# include <iostream>
# include <vector>
# include <matrix.h>

int main(void)
{
  matrix A{std::vector<std::uint32_t>{2, 1}, 5};
  std::uint32_t row1{A[0]};

  std::cout << "A = " << A << "row1 = " << row1 << '\n';

  return 0;
}

-------------------end code block-------------------

Output:
  A = 2 1
  row1 = 2


File: orthogoval.info,  Node: matrix data,  Next: matrix at,  Prev: matrix operator[],  Up: matrix.h

data
----

 -- member: container& data() &
 -- member: container data() &&
 -- member: container const& data() const&
     return container

Example:

--------------------code block--------------------

# include <iostream>
# include <vector>
# include <matrix.h>

int main(void)
{
  matrix A{std::vector<std::uint32_t>{1, 2, 3, 4}};
  std::vector<std::vector<std::uint32_t> > vec{A.data()};

  for ( auto it = vec.begin(); it != vec.end(); it++ )
    std::cout << *it << " ";
  std::cout << '\n';

  return 0;
}

-------------------end code block-------------------

Output:
  1 2 3 4


File: orthogoval.info,  Node: matrix at,  Next: matrix transpose,  Prev: matrix data,  Up: matrix.h

at
--

 -- member: std::uint32_t at(std::size_t, std::size_t) const
     entry access

Example:

--------------------code block--------------------

# include <iostream>
# include <vector>
# include <matrix.h>

int main(void)
{
  matrix A{identity_matrix32(4)};

  std::cout << "A =\n";
  A.print(std::cout);
  std::cout << "\nentry (0, 0) = " << A.at(0, 0) << '\n';

  return 0;
}

-------------------end code block-------------------

Output:
  A =
  1 0 0 0
  0 1 0 0
  0 0 1 0
  0 0 0 1

  entry (0, 0) = 1


File: orthogoval.info,  Node: matrix transpose,  Next: matrix operator==,  Prev: matrix at,  Up: matrix.h

transpose
---------

 -- member: matrix transpose() const
     return transpose of '*this'

Example:

--------------------code block--------------------

# include <iostream>
# include <vector>
# include <matrix.h>

int main(void)
{
  matrix A{std::vector<std::uint32_t>{2, 1}, 5};

  std::cout << "A =\n";
  A.print(std::cout);
  std::cout << "\nA^T =\n";
  A.transpose().print(std::cout);

  return 0;
}

-------------------end code block-------------------

Output:
  A =
  0 0 0 1 0
  0 0 0 0 1

  A^T =
  0 0
  0 0
  0 0
  1 0
  0 1


File: orthogoval.info,  Node: matrix operator==,  Next: matrix operator<=>,  Prev: matrix transpose,  Up: matrix.h

operator==
----------

 -- member: bool operator==(matrix const&) const
     check equality between matrices

Example:

--------------------code block--------------------

# include <iostream>
# include <vector>
# include <matrix.h>

int main(void)
{
  matrix A{std::vector<std::uint32_t>{2, 1}, 5};
  matrix B{std::vector<std::uint32_t>{1, 2}, 5};

  std::cout << (A == A ?  "true\n" : "false\n");
  std::cout << (A == B ?  "true\n" : "false\n");

  return 0;
}

-------------------end code block-------------------

Output:
  true
  false


File: orthogoval.info,  Node: matrix operator<=>,  Next: matrix operator*=,  Prev: matrix operator==,  Up: matrix.h

operator<=>
-----------

 -- member: auto operator<=>(matrix const&) const
     total ordering on matrix class

Example:

--------------------code block--------------------

# include <iostream>
# include <vector>
# include <matrix.h>

int main(void)
{
  matrix A{std::vector<std::uint32_t>{2, 1}, 5};
  matrix B{std::vector<std::uint32_t>{1, 2}, 5};
  auto comp = (A <=> B);

  if ( comp < 0 ) std::cout << "A < B";
  else if ( comp == 0 ) std::cout << "A == B";
  else std::cout << "A > B";

  return 0;
}

-------------------end code block-------------------

Output:
  A > B


File: orthogoval.info,  Node: matrix operator*=,  Next: matrix print,  Prev: matrix operator<=>,  Up: matrix.h

operator*=
----------

 -- member: matrix operator*=(matrix const&)
     matrix-matrix assignment multiplication

Example:

--------------------code block--------------------

# include <iostream>
# include <vector>
# include <matrix.h>

int main(void)
{
  matrix A{std::vector<std::uint32_t>{1, 2}};

  std::cout << "A =\n";
  A.print(std::cout);
  std::cout << '\n';

  A *= A;
  std::cout << "A =\n";
  A.print(std::cout);
  std::cout << '\n';

  return 0;
}

-------------------end code block-------------------

Output:
  A =
  0 1
  1 0

  A =
  1 0
  0 1


File: orthogoval.info,  Node: matrix print,  Next: matrix inverse,  Prev: matrix operator*=,  Up: matrix.h

print
-----

 -- member: void print(std::ostream&) const
     print matrix in standard/array form

Example:

--------------------code block--------------------

# include <iostream>
# include <vector>
# include <matrix.h>

int main(void)
{
  matrix A{std::vector<std::uint32_t>{1, 2}};

  std::cout << "A =\n";
  A.print(std::cout);

  return 0;
}

-------------------end code block-------------------

Output:
  A =
  0 1
  1 0


File: orthogoval.info,  Node: matrix inverse,  Next: matrix gauss_form,  Prev: matrix print,  Up: matrix.h

inverse
-------

 -- member: matrix inverse() const
     return inverse of '*this'

Example:

--------------------code block--------------------

# include <iostream>
# include <vector>
# include <matrix.h>

int main(void)
{
  matrix A{std::vector<std::uint32_t>{3, 2}};
  matrix B{A.inverse()};

  std::cout << "A =\n";
  A.print(std::cout);
  std::cout << '\n';

  std::cout << "B =\n";
  B.print(std::cout);
  std::cout << '\n';

  return 0;
}

-------------------end code block-------------------

Output:
  A =
  1 1
  1 0

  B =
  0 1
  1 1


File: orthogoval.info,  Node: matrix gauss_form,  Next: matrix rref,  Prev: matrix inverse,  Up: matrix.h

gauss_form
----------

 -- member: matrix gauss_form() const
     return row echelon form

Example:

--------------------code block--------------------

# include <iostream>
# include <vector>
# include <matrix.h>

int main(void)
{
  matrix A{std::vector<std::uint32_t>{1, 3}};
  matrix B{A.gauss_form()};

  std::cout << "A =\n";
  A.print(std::cout);
  std::cout << '\n';

  std::cout << "B =\n";
  B.print(std::cout);
  std::cout << '\n';

  return 0;
}

-------------------end code block-------------------

Output:
  A =
  0 1
  1 1

  B =
  1 1
  0 1


File: orthogoval.info,  Node: matrix rref,  Next: matrix rank,  Prev: matrix gauss_form,  Up: matrix.h

rref
----

 -- member: matrix rref() const
     return reduced row echelon form

Example:

--------------------code block--------------------

# include <iostream>
# include <vector>
# include <matrix.h>

int main(void)
{
  matrix A{std::vector<std::uint32_t>{1, 3}};
  matrix B{A.rref()};

  std::cout << "A =\n";
  A.print(std::cout);
  std::cout << '\n';

  std::cout << "B =\n";
  B.print(std::cout);
  std::cout << '\n';

  return 0;
}

-------------------end code block-------------------

Output:
  A =
  0 1
  1 1

  B =
  1 0
  0 1


File: orthogoval.info,  Node: matrix rank,  Next: matrix row_space,  Prev: matrix rref,  Up: matrix.h

rank
----

 -- member: std::size_t rank() const
     return rank of matrix

Example:

--------------------code block--------------------

# include <iostream>
# include <vector>
# include <matrix.h>

int main(void)
{
  matrix A{std::vector<std::uint32_t>{3, 3}};

  std::cout << "rank = " << A.rank() << '\n';

  return 0;
}

-------------------end code block-------------------

Output:
  rank = 1


File: orthogoval.info,  Node: matrix row_space,  Next: matrix shape,  Prev: matrix rank,  Up: matrix.h

row_space
---------

 -- member: void row_space() const
     print nonzero vectors in row space of '*this' (assumes full rank)

Example:

--------------------code block--------------------

# include <iostream>
# include <vector>
# include <matrix.h>

int main(void)
{
  matrix A{identity_matrix32(2)};
  A.row_space();

  return 0;
}

-------------------end code block-------------------

Output:
  1 2 3


File: orthogoval.info,  Node: matrix shape,  Next: matrix nrows,  Prev: matrix row_space,  Up: matrix.h

shape
-----

 -- member: dimensions& shape() &
 -- member: dimensions shape() &&
 -- member: dimensions const& shape() const&
     return row-column dimensions

Example:

--------------------code block--------------------

# include <iostream>
# include <vector>
# include <matrix.h>

int main(void)
{
  matrix A{2, 3};
  std::pair<std::size_t, std::size_t> dims{A.shape()};

  std::cout << "number of rows = " << dims.first << '\n';
  std::cout << "number of columns = " << dims.second << '\n';

  return 0;
}

-------------------end code block-------------------

Output:
  number of rows = 2
  number of columns = 3


File: orthogoval.info,  Node: matrix nrows,  Next: matrix ncols,  Prev: matrix shape,  Up: matrix.h

nrows
-----

 -- member: std::size_t& nrows() &
 -- member: std::size_t nrows() &&
 -- member: std::size_t const& nrows() const&
     return number of rows

Example:

--------------------code block--------------------

# include <iostream>
# include <vector>
# include <matrix.h>

int main(void)
{
  matrix A{2, 3};
  std::cout << "number of rows = " << A.nrows() << '\n';

  return 0;
}

-------------------end code block-------------------

Output:
  number of rows = 2


File: orthogoval.info,  Node: matrix ncols,  Next: matrix resize,  Prev: matrix nrows,  Up: matrix.h

ncols
-----

 -- member: std::size_t& ncols() &
 -- member: std::size_t ncols() &&
 -- member: std::size_t const& ncols() const&
     return number of columns

Example:

--------------------code block--------------------

# include <iostream>
# include <vector>
# include <matrix.h>

int main(void)
{
  matrix A{2, 3};
  std::cout << "number of columns = " << A.ncols() << '\n';

  return 0;
}

-------------------end code block-------------------

Output:
  number of columns = 2


File: orthogoval.info,  Node: matrix resize,  Next: matrix assignment,  Prev: matrix ncols,  Up: matrix.h

resize
------

 -- member: void resize(std::size_t n)
     resize matrix to n x n

 -- member: void resize(std::size_t n, std::size_t m)
     resize matrix to n x m

Example:

--------------------code block--------------------

# include <iostream>
# include <vector>
# include <matrix.h>

int main(void)
{
  matrix A{2, 3};
  std::pair<std::size_t, std::size_t> dims{A.shape()};

  std::cout << "number of rows = " << dims.first << '\n';
  std::cout << "number of columns = " << dims.second << "\n\n";

  A.resize(2);
  dims = A.shape();
  std::cout << "number of rows = " << dims.first << '\n';
  std::cout << "number of columns = " << dims.second << '\n';

  return 0;
}

-------------------end code block-------------------

Output:
  number of rows = 2
  number of columns = 3

  number of rows = 2
  number of columns = 2


File: orthogoval.info,  Node: matrix assignment,  Next: matrix constructors/destructor,  Prev: matrix resize,  Up: matrix.h

assignment
----------

 -- member: matrix& operator=(matrix &&) & noexcept = default
 -- member: matrix& operator=(matrix const&) & = default
     matrix assignment operation


File: orthogoval.info,  Node: matrix constructors/destructor,  Prev: matrix assignment,  Up: matrix.h

constructors/destructor
-----------------------

 -- member: matrix() = default
 -- member: matrix(matrix const&) = default
 -- member: matrix(matrix &&) noexcept = default
 -- member: explicit matrix(container const&)
 -- member: explicit matrix(container &&)
 -- member: matrix(container const&, std::size_t)
 -- member: matrix(container &&, std::size_t)
 -- member: explicit matrix(std::size_t)
 -- member: matrix(std::size_t, std::size_t)
     matrix constructors

 -- member: ~matrix() = default
     matrix destructor


File: orthogoval.info,  Node: ag.h,  Prev: matrix.h,  Up: Sec 3

3.2 ag.h
========

* Menu:

Friend Functions:
* ag operator<<:: output container
* ag operator>>:: input container
* ag operator*:: multiplicative arithmetic
* ag operator==:: check spreads for equality
* ag operator<:: total ordering on spreads
* ag orthogoval:: check if two spreads are orthogoval

Member Functions:
* ag print:: print matrix in standard/array form
* ag resize:: resize matrix to new dimensions
* ag assignment:: assigning spreads
* ag constructors/destructor:: constructing and destructing spreads


File: orthogoval.info,  Node: ag operator<<,  Next: ag operator>>,  Up: ag.h

operator<<
----------

 -- friend: std::ostream& operator<<(std::ostream&, AG const&)
     output container

Example:

--------------------code block--------------------

# include <iostream>
# include <ag.h>

int main(void)
{
  AG A{2, 3};

  std::cout << A;

  return 0;
}

-------------------end code block-------------------

Output:
  0 0 0
  0 0 0


File: orthogoval.info,  Node: ag operator>>,  Next: ag operator*,  Prev: ag operator<<,  Up: ag.h

operator>>
----------

 -- friend: std::istream& operator>>(std::istream&, AG&)
     input container

Example:

--------------------code block--------------------

# include <iostream>
# include <ag.h>

int main(void)
{
  AG A{2, 3};

  std::cin >> A;
  std::cout << A;

  return 0;
}

-------------------end code block-------------------

Input:
  1 2 3
  4 5 6

Output:
  1 2 3
  4 5 6


File: orthogoval.info,  Node: ag operator*,  Next: ag operator==,  Prev: ag operator>>,  Up: ag.h

operator*
---------

 -- friend: AG operator*(matrix const&, AG const&)
     apply matrix/linear transform to each space in spread

Example:

--------------------code block--------------------

# include <iostream>
# include <ag.h>
# include <matrix.h>

int main(void)
{
  AG A1{2, 3};

  std::cin >> A1;
  std::cout << "A1 =\n" << A1 << '\n';

  matrix B{std::vector<std::uint32_t>{2, 0, 0}};
  std::cout << "B =\n";
  B.print(std::cout);
  std::cout << '\n';

  AG A2{B * A1};
  std::cout << "A2 =\n" << A2;

  return 0;
}

-------------------end code block-------------------

Input:
  1 2 3
  4 5 6

Output:
  A1 =
  1 2 3
  4 5 6

  B =
  0 1 0
  0 0 0
  0 0 0

  A2 =
  0 4 4
  0 0 4


File: orthogoval.info,  Node: ag operator==,  Next: ag operator<,  Prev: ag operator*,  Up: ag.h

operator==
----------

 -- friend: bool operator==(AG const&, AG const&)
     check spreads for equality

Example:

--------------------code block--------------------

# include <iostream>
# include <ag.h>

int main(void)
{
  AG A1{2, 3}, A2{2, 3};

  std::cin >> A1 >> A2;
  std::cout << (A1 == A1 ?  "true\n" : "false\n");
  std::cout << (A1 == A2 ?  "true\n" : "false\n");

  return 0;
}

-------------------end code block-------------------

Input:
  1 2 3 4 5 6
  2 3 4 5 6 7

Output:
  true
  false


File: orthogoval.info,  Node: ag operator<,  Next: ag orthogoval,  Prev: ag operator==,  Up: ag.h

operator<
---------

 -- friend: bool operator<(AG const&, AG const&)
     total ordering on spreads

Example:

--------------------code block--------------------

# include <iostream>
# include <ag.h>

int main(void)
{
  AG A1{2, 3}, A2{2, 3};

  std::cin >> A1 >> A2;
  std::cout << (A1 < A1 ?  "true\n" : "false\n");
  std::cout << (A1 < A2 ?  "true\n" : "false\n");

  return 0;
}

-------------------end code block-------------------

Input:
  1 2 3 4 5 6
  2 3 4 5 6 7

Output:
  false
  true


File: orthogoval.info,  Node: ag orthogoval,  Next: ag print,  Prev: ag operator<,  Up: ag.h

orthogoval
----------

 -- friend: bool orthogoval(AG const&, AG const&)
     check if two spreads are orthogoval

Example:

--------------------code block--------------------

# include <iostream>
# include <ag.h>

int main(void)
{
  AG A1{5, 4}, A2{5, 4};

  std::cin >> A1 >> A2;
  std::cout << (orthogoval(A1, A2) ?  "true\n" : "false\n");

  return 0;
}

-------------------end code block-------------------

Input:
  0 1 6 7 0 2 12 14 0 4 11 15 0 8 5 13 0 3 10 9
  0 1 2 3 0 4 10 14 0 5 9 12 0 6 11 13 0 7 8 15

Output:
  true


File: orthogoval.info,  Node: ag print,  Next: ag resize,  Prev: ag orthogoval,  Up: ag.h

print
-----

 -- member: void print() const
     print matrix in standard/array form

Example:

--------------------code block--------------------

# include <iostream>
# include <ag.h>

int main(void)
{
  AG A1{2, 4};

  std::cin >> A1;
  A1.print();

  return 0;
}

-------------------end code block-------------------

Input:
  0 1 6 7 0 2 12 14

Output:
  0 0 0 0
  0 0 0 1
  0 1 1 0
  0 1 1 1

  0 0 0 0
  0 0 1 0
  1 1 0 0
  1 1 1 0


File: orthogoval.info,  Node: ag resize,  Next: ag assignment,  Prev: ag print,  Up: ag.h

resize
------

 -- member: void resize(std::size_t, std::size_t)
     resize matrix to new dimensions

Example:

--------------------code block--------------------

# include <iostream>
# include <ag.h>

int main(void)
{
  AG A1{2, 4};

  std::cin >> A1;
  std::cout << A1 << '\n';

  A1.resize(3, 4);
  std::cout << A1;

  return 0;
}

-------------------end code block-------------------

Input:
  0 1 6 7 0 2 12 14

Output:
  0 1 6 7
  0 2 12 14

  0 1 6 7
  0 2 12 14
  0 0 0 0


File: orthogoval.info,  Node: ag assignment,  Next: ag constructors/destructor,  Prev: ag resize,  Up: ag.h

assignment
----------

 -- member: AG& operator=(AG &&) & noexcept = default
 -- member: AG& operator=(AG const&) & = default
     assigning spreads


File: orthogoval.info,  Node: ag constructors/destructor,  Prev: ag assignment,  Up: ag.h

constructors/destructor
-----------------------

 -- member: AG() = default
 -- member: AG(AG const&) = default
 -- member: AG(AG &&) noexcept = default
 -- member: AG(std::size_t, std::size_t)
     AG constructors

 -- member: ~AG() = default
     AG destructor


File: orthogoval.info,  Node: Sec 4,  Next: Sec 5,  Prev: Sec 3,  Up: Top

4 Executable Documentation
**************************

There are five executables included in this package:

* Menu:


* transversal:: calculate orbit of canonical spread
* automorphisms:: calculate orbit and autorphism group of canonical spread
* mutually_orthogoval:: find maximal sets of mutually orthogoval sets via clique search
* feasible_coverings:: find maximal sets of mutually orthogoval sets via exact cover search
* feasible_subspaces:: find all subspaces capable of forming a spread orthogoval to the canonical spread


File: orthogoval.info,  Node: transversal,  Next: automorphisms,  Up: Sec 4

transversal
===========

The executable 'transversal' is used to find all the spreads which are
orthogoval to the canonical spread 'L'.  The orbit of 'L' under the
natural action of 'GL(n, q)' is calculated.  As each distinct isomorphic
copy of 'L' is found, it is tested for whether it is orthogoval to 'L'.
If it is, it is printed to 'stdout'.  The total number of orthogoval
isomorphic copies of 'L' are printed at the conclusion of the execution.

Usage:

From the top of the build directory, run

   './src/transversal <degree> <order> <canonical_spread_file>'

The parameters are as follows:

   * '<degree>' - degree of the canonical spread
   * '<order>' - order of the canonical spread
   * 'canonical_spread_file' - the canonical spread is stored in this
     file and can be generated by the Bourne script
     'canonical_spread.sh' in the directory 'data'


File: orthogoval.info,  Node: automorphisms,  Next: mutually_orthogoval,  Prev: transversal,  Up: Sec 4

automorphisms
=============

The executable 'automorphisms' is used to find all the spreads which are
orthogoval to the canonical spread 'L'.  The orbit of 'L' under the
natural action of 'GL(n, q)' is calculated.  In addition, the
automorphism group of 'L' is calculated and printed to the file
'automorphisms.txt', a transversal for the action is printed to
'transversal.txt', the transversal elements giving orthogoval isomorphic
copies of 'L' are printed to 'orthogoval_transversal.txt', the
orthogoval isomorphic copies of 'L' are printed to 'vertices.txt'.

Usage:

From the top of the build directory, run

   './src/automorphisms <degree> <order> <canonical_spread_file>'

The parameters are as follows:

   * '<degree>' - degree of the canonical spread
   * '<order>' - order of the canonical spread
   * 'canonical_spread_file' - the canonical spread is stored in this
     file and can be generated by the Bourne script
     'canonical_spread.sh' in the directory 'data'


File: orthogoval.info,  Node: mutually_orthogoval,  Next: feasible_coverings,  Prev: automorphisms,  Up: Sec 4

mutually_orthogoval
===================

Let 'L' be the canonical line spread, and suppose the orthogoval
isomorphic copies of 'L' have been stored in the file 'vertices.txt'
(say, using executables 'transversal' or 'automorphisms' included in
this package).  The executable 'mutually_orthogoval' generates a graph
using these isomorphic copies as vertices with the symmetric relation
given by orthogovalility.  'Cliquer' is then used to search for cliques
in this graph, which amount to sets of mutually orthogoval planes
containing 'L'.

Usage:

From the top of the build directory, run

   './src/mutually_orthogoval <nvertices> <order>'

The vertices are read from 'stdin'.  The cliques are output to 'stdout'
The parameters are as follows:

   * '<nvertices>' - the number of orthogoval isomorphic copies of 'L'
     contained in the file 'vertices.txt'
   * '<order>' - the order of the canonical line spread 'L'


File: orthogoval.info,  Node: feasible_coverings,  Next: feasible_subspaces,  Prev: mutually_orthogoval,  Up: Sec 4

feasible_coverings
==================

The executable 'feasible_coverings' takes the nonzero vectors of the
feasible subspaces generated by the executable 'feasible_subspaces' and
performs Knuth's Algorithm X for exact covers to find maximal sets of
mutually orthogoval affine planes containing the canonical line spread.

Usage:

From the top of the build directory, run

   './src/feasible_coverings <nitems> <noptions> <optsize>'

The options (feasible subspaces) are read from 'stdin'.  The coverings
are written to 'stdout'.  The parameters are as follows:

   * '<nitems>' - number of nonzero vectors in the ambient vector space
   * '<noptions>' - number of feasible subspaces
   * '<optsize>' - number of nozero vectors in feasible subspace


File: orthogoval.info,  Node: feasible_subspaces,  Prev: feasible_coverings,  Up: Sec 4

feasible_subspaces
==================

Let 'L' be the canonical spread.  The executable 'feasible_subspaces'
generates all those subspaces of the appropriate size which intersect
each subspace contained in 'L' in a space of dimension at most 1.

Usage:

From the top of the build directory, run

   './src/feasible_subspaces <degree>'

Bases for the canonical spread are read from 'stdin' and can be
generated by the script 'spread_basis.sh' contained in the 'data'
directory.  The feasible subspaces are written to 'stdout'.  From the
top of the build directory run

   './src/feasible_subspaces <2degree>'

   The parameters are as follows:

   * '<2degree>' - twice the degree of the canonical spread


File: orthogoval.info,  Node: Sec 5,  Prev: Sec 4,  Up: Top

5 GNU Free Documentation License
********************************

* Menu:


* Subsec 1:: PREAMBLE
* Subsec 2:: APPLICABILITY AND DEFINITIONS
* Subsec 3:: VERBATIM COPYING
* Subsec 4:: COPYING IN QUANTITY
* Subsec 5:: MODIFICATIONS
* Subsec 6:: COMBINING DOCUMENTS
* Subsec 7:: COLLECTIONS OF DOCUMENTS
* Subsec 8:: AGGREGATION WITH INDEPENDENT WORKS
* Subsec 9:: TRANSLATION
* Subsec 10:: TERMINATION
* Subsec 11:: FUTURE REVISIONS OF THIS LICENSE
* Subsec 12:: RELICENSING


File: orthogoval.info,  Node: Subsec 1,  Next: Subsec 2,  Up: Sec 5

5.1 PREAMBLE
============

The purpose of this License is to make a manual, textbook, or other
functional and useful document free in the sense of freedom: to assure
everyone the effective freedom to copy and redistribute it, with or
without modifying it, either commercially or noncommercially.
Secondarily, this License preserves for the author and publisher a way
to get credit for their work, while not being considered responsible for
modifications made by others.

   This License is a kind of “copyleft”, which means that derivative
works of the document must themselves be free in the same sense.  It
complements the GNU General Public License, which is a copyleft license
designed for free software.

   We have designed this License in order to use it for manuals for free
software, because free software needs free documentation: a free program
should come with manuals providing the same freedoms that the software
does.  But this License is not limited to software manuals; it can be
used for any textual work, regardless of subject matter or whether it is
published as a printed book.  We recommend this License principally for
works whose purpose is instruction or reference.


File: orthogoval.info,  Node: Subsec 2,  Next: Subsec 3,  Prev: Subsec 1,  Up: Sec 5

5.2 APPLICABILITY AND DEFINITIONS
=================================

This License applies to any manual or other work, in any medium, that
contains a notice placed by the copyright holder saying it can be
distributed under the terms of this License.  Such a notice grants a
world-wide, royalty-free license, unlimited in duration, to use that
work under the conditions stated herein.  The “Document”, below, refers
to any such manual or work.  Any member of the public is a licensee, and
is addressed as “you”.  You accept the license if you copy, modify or
distribute the work in a way requiring permission under copyright law.

   A “Modified Version” of the Document means any work containing the
Document or a portion of it, either copied verbatim, or with
modifications and/or translated into another language.

   A “Secondary Section” is a named appendix or a front-matter section
of the Document that deals exclusively with the relationship of the
publishers or authors of the Document to the Document’s overall subject
(or to related matters) and contains nothing that could fall directly
within that overall subject.  (Thus, if the Document is in part a
textbook of mathematics, a Secondary Section may not explain any
mathematics.)  The relationship could be a matter of historical
connection with the subject or with related matters, or of legal,
commercial, philosophical, ethical or political position regarding them.

   The “Invariant Sections” are certain Secondary Sections whose titles
are designated, as being those of Invariant Sections, in the notice that
says that the Document is released Appendix G: GNU Free Documentation
License 300 under this License.  If a section does not fit the above
definition of Secondary then it is not allowed to be designated as
Invariant.  The Document may contain zero Invariant Sections.  If the
Document does not identify any Invariant Sections then there are none.

   The “Cover Texts” are certain short passages of text that are listed,
as Front-Cover Texts or Back-Cover Texts, in the notice that says that
the Document is released under this License.  A Front-Cover Text may be
at most 5 words, and a Back-Cover Text may be at most 25 words.

   A “Transparent” copy of the Document means a machine-readable copy,
represented in a format whose specification is available to the general
public, that is suitable for revising the document straightforwardly
with generic text editors or (for images composed of pixels) generic
paint programs or (for drawings) some widely available drawing editor,
and that is suitable for input to text formatters or for automatic
translation to a variety of formats suitable for input to text
formatters.  A copy made in an otherwise Transparent file format whose
markup, or absence of markup, has been arranged to thwart or discourage
subsequent modification by readers is not Transparent.  An image format
is not Transparent if used for any substantial amount of text.  A copy
that is not “Transparent” is called “Opaque”.

   Examples of suitable formats for Transparent copies include plain
ASCII without markup, Texinfo input format, LaTEX input format, SGML or
XML using a publicly available DTD, and standard-conforming simple HTML,
PostScript or PDF designed for human modification.  Examples of
transparent image formats include PNG, XCF and JPG. Opaque formats
include proprietary formats that can be read and edited only by
proprietary word processors, SGML or XML for which the DTD and/or
processing tools are not generally available, and the machine-generated
HTML, PostScript or PDF produced by some word processors for output
purposes only.

   The “Title Page” means, for a printed book, the title page itself,
plus such following pages as are needed to hold, legibly, the material
this License requires to appear in the title page.  For works in formats
which do not have any title page as such, “Title Page” means the text
near the most prominent appearance of the work’s title, preceding the
beginning of the body of the text.

   The “publisher” means any person or entity that distributes copies of
the Document to the public.

   A section “Entitled XYZ” means a named subunit of the Document whose
title either is precisely XYZ or contains XYZ in parentheses following
text that translates XYZ in another language.  (Here XYZ stands for a
specific section name mentioned below, such as “Acknowledgements”,
“Dedications”, “Endorsements”, or “History”.)  To “Preserve the Title”
of such a section when you modify the Document means that it remains a
section “Entitled XYZ” according to this definition.

   The Document may include Warranty Disclaimers next to the notice
which states that this License applies to the Document.  These Warranty
Disclaimers are considered to be included by reference in this License,
but only as regards disclaiming warranties: any other implication that
these Warranty Disclaimers may have is void and has no effect on the
meaning of this License.


File: orthogoval.info,  Node: Subsec 3,  Next: Subsec 4,  Prev: Subsec 2,  Up: Sec 5

5.3 VERBATIM COPYING
====================

You may copy and distribute the Document in any medium, either
commercially or noncommercially, provided that this License, the
copyright notices, and the license notice saying this License applies to
the Document are reproduced in all copies, and that you add no other
conditions whatsoever to those of this License.  You may not use
technical measures to obstruct or control the reading or further copying
of the copies you make or distribute.  However, you may accept
compensation in exchange for copies.  If you distribute a large enough
number of copies you must also follow the conditions in section 3.

   You may also lend copies, under the same conditions stated above, and
you may publicly display copies.


File: orthogoval.info,  Node: Subsec 4,  Next: Subsec 5,  Prev: Subsec 3,  Up: Sec 5

5.4 COPYING IN QUANTITY
=======================

If you publish printed copies (or copies in media that commonly have
printed covers) of the Document, numbering more than 100, and the
Document’s license notice requires Cover Texts, you must enclose the
copies in covers that carry, clearly and legibly, all these Cover Texts:
Front-Cover Texts on the front cover, and Back-Cover Texts on the back
cover.  Both covers must also clearly and legibly identify you as the
publisher of these copies.  The front cover must present the full title
with all words of the title equally prominent and visible.  You may add
other material on the covers in addition.  Copying with changes limited
to the covers, as long as they preserve the title of the Document and
satisfy these conditions, can be treated as verbatim copying in other
respects.

   If the required texts for either cover are too voluminous to fit
legibly, you should put the first ones listed (as many as fit
reasonably) on the actual cover, and continue the rest onto adjacent
pages.

   If you publish or distribute Opaque copies of the Document numbering
more than 100, you must either include a machine-readable Transparent
copy along with each Opaque copy, or state in or with each Opaque copy a
computer-network location from which the general network-using public
has access to download using public-standard network protocols a
complete Transparent copy of the Document, free of added material.  If
you use the latter option, you must take reasonably prudent steps, when
you begin distribution of Opaque copies in quantity, to ensure that this
Transparent copy will remain thus accessible at the stated location
until at least one year after the last time you distribute an Opaque
copy (directly or through your agents or retailers) of that edition to
the public.

   It is requested, but not required, that you contact the authors of
the Document well before redistributing any large number of copies, to
give them a chance to provide you with an updated version of the
Document.


File: orthogoval.info,  Node: Subsec 5,  Next: Subsec 6,  Prev: Subsec 4,  Up: Sec 5

5.5 MODIFICATIONS
=================

You may copy and distribute a Modified Version of the Document under the
conditions of sections 2 and 3 above, provided that you release the
Modified Version under precisely this License, with the Modified Version
filling the role of the Document, thus licensing distribution and
modification of the Modified Version to whoever possesses a copy of it.
In addition, you must do these things in the Modified Version:

  1. Use in the Title Page (and on the covers, if any) a title distinct
     from that of the Document, and from those of previous versions
     (which should, if there were any, be listed in the History section
     of the Document).  You may use the same title as a previous version
     if the original publisher of that version gives permission.

  2. List on the Title Page, as authors, one or more persons or entities
     responsible for authorship of the modifications in the Modified
     Version, together with at least five of the principal authors of
     the Document (all of its principal authors, if it has fewer than
     five), unless they release you from this requirement.

  3. State on the Title page the name of the publisher of the Modified
     Version, as the publisher.

  4. Preserve all the copyright notices of the Document.

  5. Add an appropriate copyright notice for your modifications adjacent
     to the other copyright notices.

  6. Include, immediately after the copyright notices, a license notice
     giving the public permission to use the Modified Version under the
     terms of this License, in the form shown in the Addendum below.

  7. Preserve in that license notice the full lists of Invariant
     Sections and required Cover Texts given in the Document’s license
     notice.

  8. Include an unaltered copy of this License.

  9. Preserve the section Entitled “History”, Preserve its Title, and
     add to it an item stating at least the title, year, new authors,
     and publisher of the Modified Version as given on the Title Page.
     If there is no section Entitled “History” in the Document, create
     one stating the title, year, authors, and publisher of the Document
     as given on its Title Page, then add an item describing the
     Modified Version as stated in the previous sentence.

  10. Preserve the network location, if any, given in the Document for
     public access to a Transparent copy of the Document, and likewise
     the network locations given in the Document for previous versions
     it was based on.  These may be placed in the “History” section.
     You may omit a network location for a work that was published at
     least four years before the Document itself, or if the original
     publisher of the version it refers to gives permission.

  11. For any section Entitled “Acknowledgements” or “Dedications”,
     Preserve the Title of the section, and preserve in the section all
     the substance and tone of each of the contributor acknowledgements
     and/or dedications given therein.

  12. Preserve all the Invariant Sections of the Document, unaltered in
     their text and in their titles.  Section numbers or the equivalent
     are not considered part of the section titles.

  13. Delete any section Entitled “Endorsements”.  Such a section may
     not be included in the Modified Version.

  14. Do not retitle any existing section to be Entitled “Endorsements”
     or to conflict in title with any Invariant Section.

  15. Preserve any Warranty Disclaimers.


File: orthogoval.info,  Node: Subsec 6,  Next: Subsec 7,  Prev: Subsec 5,  Up: Sec 5

5.6 COMBINING DOCUMENTS
=======================

You may combine the Document with other documents released under this
License, under the terms defined in section 4 above for modified
versions, provided that you include in the combination all of the
Invariant Sections of all of the original documents, unmodified, and
list them all as Invariant Sections of your combined work in its license
notice, and that you preserve all their Warranty Disclaimers.

   The combined work need only contain one copy of this License, and
multiple identical Invariant Sections may be replaced with a single
copy.  If there are multiple Invariant Sections with the same name but
different contents, make the title of each such section unique by adding
at the end of it, in parentheses, the name of the original author or
publisher of that section if known, or else a unique number.  Make the
same adjustment to the section titles in the list of Invariant Sections
in the license notice of the combined work.

   In the combination, you must combine any sections Entitled “History”
in the various original documents, forming one section Entitled
“History”; likewise combine any sections Entitled “Acknowledgements”,
and any sections Entitled “Dedications”.  You must delete all sections
Entitled “Endorsements.”


File: orthogoval.info,  Node: Subsec 7,  Next: Subsec 8,  Prev: Subsec 6,  Up: Sec 5

5.7 COLLECTIONS OF DOCUMENTS
============================

You may make a collection consisting of the Document and other documents
released under this License, and replace the individual copies of this
License in the various documents with a single copy that is included in
the collection, provided that you follow the rules of this License for
verbatim copying of each of the documents in all other respects.

   You may extract a single document from such a collection, and
distribute it individually under this License, provided you insert a
copy of this License into the extracted document, and follow this
License in all other respects regarding verbatim copying of that
document.


File: orthogoval.info,  Node: Subsec 8,  Next: Subsec 9,  Prev: Subsec 7,  Up: Sec 5

5.8 AGGREGATION WITH INDEPENDENT WORKS
======================================

A compilation of the Document or its derivatives with other separate and
independent documents or works, in or on a volume of a storage or
distribution medium, is called an “aggregate” if the copyright resulting
from the compilation is not used to limit the legal rights of the
compilation’s users beyond what the individual works permit.  When the
Document is included in an aggregate, this License does not apply to the
other works in the aggregate which are not themselves derivative works
of the Document.

   If the Cover Text requirement of section 3 is applicable to these
copies of the Document, then if the Document is less than one half of
the entire aggregate, the Document’s Cover Texts may be placed on covers
that bracket the Document within the aggregate, or the electronic
equivalent of covers if the Document is in electronic form.  Otherwise
they must appear on printed covers that bracket the whole aggregate.


File: orthogoval.info,  Node: Subsec 9,  Next: Subsec 10,  Prev: Subsec 8,  Up: Sec 5

5.9 TRANSLATION
===============

Translation is considered a kind of modification, so you may distribute
translations of the Document under the terms of section 4.  Replacing
Invariant Sections with translations requires special permission from
their copyright holders, but you may include translations of some or all
Invariant Sections in addition to the original versions of these
Invariant Sections.  You may include a translation of this License, and
all the license notices in the Document, and any Warranty Disclaimers,
provided that you also include the original English version of this
License and the original versions of those notices and disclaimers.  In
case of a disagreement between the translation and the original version
of this License or a notice or disclaimer, the original version will
prevail.

   If a section in the Document is Entitled “Acknowledgements”,
“Dedications”, or “History”, the requirement (section 4) to Preserve its
Title (section 1) will typically require changing the actual title.


File: orthogoval.info,  Node: Subsec 10,  Next: Subsec 11,  Prev: Subsec 9,  Up: Sec 5

5.10 TERMINATION
================

You may not copy, modify, sublicense, or distribute the Document except
as expressly provided under this License.  Any attempt otherwise to
copy, modify, sublicense, or distribute it is void, and will
automatically terminate your rights under this License.

   However, if you cease all violation of this License, then your
license from a particular copyright holder is reinstated (a)
provisionally, unless and until the copyright holder explicitly and
finally terminates your license, and (b) permanently, if the copyright
holder fails to notify you of the violation by some reasonable means
prior to 60 days after the cessation.

   Moreover, your license from a particular copyright holder is
reinstated permanently if the copyright holder notifies you of the
violation by some reasonable means, this is the first time you have
received notice of violation of this License (for any work) from that
copyright holder, and you cure the violation prior to 30 days after your
receipt of the notice.

   Termination of your rights under this section does not terminate the
licenses of parties who have received copies or rights from you under
this License.  If your rights have been terminated and not permanently
reinstated, receipt of a copy of some or all of the same material does
not give you any rights to use it.


File: orthogoval.info,  Node: Subsec 11,  Next: Subsec 12,  Prev: Subsec 10,  Up: Sec 5

5.11 FUTURE REVISIONS OF THIS LICENSE
=====================================

The Free Software Foundation may publish new, revised versions of the
GNU Free Documentation License from time to time.  Such new versions
will be similar in spirit to the present version, but may differ in
detail to address new problems or concerns.  See
https://www.gnu.org/licenses/.

   Each version of the License is given a distinguishing version number.
If the Document specifies that a particular numbered version of this
License “or any later version” applies to it, you have the option of
following the terms and conditions either of that specified version or
of any later version that has been published (not as a draft) by the
Free Software Foundation.  If the Document does not specify a version
number of this License, you may choose any version ever published (not
as a draft) by the Free Software Foundation.  If the Document specifies
that a proxy can decide which future versions of this License can be
used, that proxy’s public statement of acceptance of a version
permanently authorizes you to choose that version for the Document.


File: orthogoval.info,  Node: Subsec 12,  Prev: Subsec 11,  Up: Sec 5

5.12 RELICENSING
================

“Massive Multiauthor Collaboration Site” (or “MMC Site”) means any World
Wide Web server that publishes copyrightable works and also provides
prominent facilities for anybody to edit those works.  A public wiki
that anybody can edit is an example of such a server.  A “Massive
Multiauthor Collaboration” (or “MMC”) contained in the site means any
set of copyrightable works thus published on the MMC site.

   “CC-BY-SA” means the Creative Commons Attribution-Share Alike 3.0
license published by Creative Commons Corporation, a not-for-profit
corporation with a principal place of business in San Francisco,
California, as well as future copyleft versions of that license
published by that same organization.

   “Incorporate” means to publish or republish a Document, in whole or
in part, as part of another Document.

   An MMC is “eligible for relicensing” if it is licensed under this
License, and if all works that were first published under this License
somewhere other than this MMC, and subsequently incorporated in whole or
in part into the MMC, (1) had no cover texts or invariant sections, and
(2) were thus incorporated prior to November 1, 2008.

   The operator of an MMC Site may republish an MMC contained in the
site under CC-BY-SA on the same site at any time before August 1, 2009,
provided the MMC is eligible for relicensing.



Tag Table:
Node: Top516
Node: Sec 11394
Node: Sec 21505
Node: Sec 32064
Node: matrix.h2307
Node: matrix operator<<3762
Node: matrix operator>>4296
Node: matrix operator*4816
Node: matrix operator[]6021
Node: matrix data6718
Node: matrix at7409
Node: matrix transpose8024
Node: matrix operator==8672
Node: matrix operator<=>9332
Node: matrix operator*=10031
Node: matrix print10708
Node: matrix inverse11248
Node: matrix gauss_form11906
Node: matrix rref12573
Node: matrix rank13221
Node: matrix row_space13726
Node: matrix shape14239
Node: matrix nrows14966
Node: matrix ncols15542
Node: matrix resize16128
Node: matrix assignment17066
Node: matrix constructors/destructor17369
Node: ag.h17999
Node: ag operator<<18585
Node: ag operator>>19020
Node: ag operator*19510
Node: ag operator==20302
Node: ag operator<20908
Node: ag orthogoval21509
Node: ag print22139
Node: ag resize22672
Node: ag assignment23248
Node: ag constructors/destructor23509
Node: Sec 423866
Node: transversal24475
Node: automorphisms25423
Node: mutually_orthogoval26513
Node: feasible_coverings27547
Node: feasible_subspaces28416
Node: Sec 529212
Node: Subsec 129751
Node: Subsec 231018
Node: Subsec 336185
Node: Subsec 437033
Node: Subsec 539168
Node: Subsec 642818
Node: Subsec 744222
Node: Subsec 844998
Node: Subsec 946103
Node: Subsec 1047227
Node: Subsec 1148670
Node: Subsec 1249897

End Tag Table


Local Variables:
coding: utf-8
End:
